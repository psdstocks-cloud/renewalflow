generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // Supavisor Session Mode (port 5432) supports prepared statements
  // Supavisor Transaction Mode (port 6543) does NOT support prepared statements
  // If using Transaction Mode, add ?pgbouncer=true to connection string
}

model Tenant {
  id        String   @id
  name      String
  timezone  String   @default("Africa/Cairo")
  createdAt DateTime @default(now())

  customers         Customer[]
  pointsBatches     PointsBatch[]
  pointsTransactions PointsTransaction[]
  walletSnapshots   WalletSnapshot[]
  reminderRules     ReminderRule[]
  reminderJobs      ReminderJob[]
  subscriptions     Subscription[]
}

model Customer {
  id              BigInt   @id @default(autoincrement())
  tenantId        String
  externalUserId  BigInt
  email           String
  phone           String?
  whatsapp        String?
  locale          String   @default("en")
  timezone        String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  tenant          Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  pointsBatches   PointsBatch[]
  pointsTransactions PointsTransaction[]
  walletSnapshots WalletSnapshot[]
  reminderJobs    ReminderJob[]
  subscriptions   Subscription[]

  @@unique([tenantId, externalUserId])
}

model PointsBatch {
  id               BigInt   @id @default(autoincrement())
  tenantId         String
  customerId       BigInt
  source           String
  externalOrderId  String?
  pointsTotal      Int
  pointsRemaining  Int
  purchasedAt      DateTime
  expiresAt        DateTime
  status           String   @default("active")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer        Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  transactions    PointsTransaction[]

  @@index([customerId])
  @@index([expiresAt, status])
}

model PointsTransaction {
  id               BigInt   @id @default(autoincrement())
  tenantId         String
  customerId       BigInt
  batchId          BigInt?
  delta            Int
  type             String
  description      String?
  referenceType    String?
  referenceId      String?
  externalEventId  BigInt?
  createdAt        DateTime @default(now())

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  batch    PointsBatch? @relation(fields: [batchId], references: [id], onDelete: SetNull)

  @@index([customerId, createdAt])
  @@unique([tenantId, externalEventId])
}

model WalletSnapshot {
  tenantId      String
  customerId    BigInt
  pointsBalance Int
  updatedAt     DateTime @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@id([tenantId, customerId])
}

model ReminderRule {
  id          BigInt   @id @default(autoincrement())
  tenantId    String
  name        String
  eventType   String
  offsetType  String
  offsetValue Int
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant      Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  reminderJobs ReminderJob[]
}

model ReminderJob {
  id           BigInt   @id @default(autoincrement())
  tenantId     String
  ruleId       BigInt
  customerId   BigInt
  channel      String
  scheduledFor DateTime
  status       String   @default("pending")
  payload      Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant    Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  rule      ReminderRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  customer  Customer     @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model Subscription {
  id                    BigInt   @id @default(autoincrement())
  tenantId              String
  customerId            BigInt?
  externalSubscriptionId String
  status                String
  planName              String?
  nextPaymentDate       DateTime?
  currentPeriodEnd      DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  tenant    Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  customer  Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  @@unique([tenantId, externalSubscriptionId])
}

model Subscriber {
  id              String     @id @default(cuid())
  workspaceId     String
  name            String
  email           String     @unique
  phone           String?
  planName        String
  amount          Float
  currency        String     @default("EGP")
  pointsRemaining Int        @default(0)
  status          String
  startDate       DateTime
  endDate         DateTime
  paymentLink     String?
  lastNotifiedAt  DateTime?
  lastPurchaseDate DateTime?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  emailLogs       EmailLog[]

  workspace       Workspace  @relation(fields: [workspaceId], references: [id])
  pointHistory    PointHistory[]
  revenueTransactions RevenueTransaction[]
}

model PointHistory {
  id           String     @id @default(cuid())
  subscriberId String
  subscriber   Subscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  change       Int
  reason       String
  date         DateTime   @default(now())
  externalId   String?    @unique // To prevent duplicate syncs
  createdAt    DateTime   @default(now())

  @@index([subscriberId])
}

model EmailLog {
  id           String     @id @default(cuid())
  workspaceId  String
  subscriberId String
  subscriber   Subscriber @relation(fields: [subscriberId], references: [id])
  type         String
  subject      String
  body         String
  method       String
  success      Boolean
  error        String?
  sentAt       DateTime   @default(now())
  
  // Conversion tracking fields
  openedAt     DateTime?  // Email open tracking
  clickedAt    DateTime?  // Link click tracking
  convertedAt  DateTime?  // Conversion (renewal) timestamp

  workspace    Workspace  @relation(fields: [workspaceId], references: [id])
  revenueTransactions RevenueTransaction[]
}

model AppSettings {
  id          String     @id @default(cuid())
  workspaceId String
  key         String
  value       Json

  workspace   Workspace  @relation(fields: [workspaceId], references: [id])

  @@unique([workspaceId, key])
}

model Workspace {
  id          String          @id @default(cuid())
  name        String
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  users       WorkspaceUser[]
  subscribers Subscriber[]
  emailLogs   EmailLog[]
  appSettings AppSettings[]
  websiteConnections WebsiteConnection[]
  revenueTransactions RevenueTransaction[]
}

model WorkspaceUser {
  id          String     @id @default(cuid())
  workspaceId String
  userId      String
  role        String

  workspace   Workspace  @relation(fields: [workspaceId], references: [id])

  @@unique([workspaceId, userId])
}

model WebsiteConnection {
  id          String     @id @default(cuid())
  workspaceId String
  websiteUrl  String
  apiKey      String     @unique
  isActive    Boolean    @default(true)
  lastSyncAt  DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  workspace   Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, websiteUrl])
  @@index([apiKey])
}

model RevenueTransaction {
  id                String     @id @default(cuid())
  workspaceId       String
  subscriberId      String
  subscriber        Subscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)
  
  // Transaction details
  amount            Float
  currency          String     @default("EGP")
  transactionType   String     // 'renewal', 'new_purchase', 'upgrade', 'downgrade', 'refund'
  paymentMethod     String?    // 'credit_card', 'paypal', 'bank_transfer', etc.
  paymentStatus     String     @default("completed") // 'completed', 'pending', 'failed', 'refunded'
  
  // Attribution
  emailLogId        String?    // Link to reminder email that triggered renewal
  emailLog          EmailLog?  @relation(fields: [emailLogId], references: [id], onDelete: SetNull)
  
  // External references
  externalOrderId   String?    // WooCommerce order ID
  externalChargeId  String?    // External charge/payment ID
  
  // Plan information
  planName          String?
  planAmount        Float?     // Amount at time of transaction
  
  // Timestamps
  transactionDate   DateTime   @default(now())
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  
  workspace         Workspace  @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  
  @@index([subscriberId])
  @@index([workspaceId, transactionDate])
  @@index([transactionType])
  @@index([paymentStatus])
  @@index([emailLogId]) // For attribution tracking
  @@index([externalOrderId]) // For deduplication
}
